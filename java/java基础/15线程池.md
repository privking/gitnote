# 线程池

## 两种线程模型

- ULT（用户线程）：用户程序实现，不依赖于操作系统核心，应用提供创建，同步，调度和管理线程的函数来控制用户线程，**不需要用户态，内核态的切换**，速度快，内核对ULT无感知，线程阻塞则进程（包括它所有线程）阻塞
- KLT（内核线程）：系统内核管理线程，内核保存线程的状态和上下文信息，**线程阻塞不会引起进程阻塞**，在多处理器系统上，多线程在多处理器上运行，多线程在多处理器上并行运行。线程的创建、调度、管理由内核完成，效率比ULT忙，比进程操作快
- JVM使用KLT线程模型

![image-20201123181426745](https://raw.githubusercontent.com/privking/king-note-images/master/img/note/image-20201123181426745-1606126473-db4b93.png)

## ThreadPoolExecutor

```java


 public ThreadPoolExecutor(int corePoolSize,  //核心线程数
                              int maximumPoolSize, //最大线程数
                              long keepAliveTime, //非核心线程数在等在新任务多长时间后关闭
                              TimeUnit unit,
                              //阻塞队列，LinkedBlockingQueue 最大为Integer.maxSize,ArrayBlockingQueue(10)可以指定队列长度
                              BlockingQueue<Runnable> workQueue, 
                              //创建线程的工厂
                              ThreadFactory threadFactory,
                              //线程池拒绝策略
                              RejectedExecutionHandler handler)
```

### 线程池简单结构

![3c35ede5f2a76403624cc7cbb4e7154](https://raw.githubusercontent.com/privking/king-note-images/master/img/note/3c35ede5f2a76403624cc7cbb4e7154-1606143695-4e2986.png)

### 线程池5种状态

![7ae1c256983120d31d9c374a78f32cf](https://raw.githubusercontent.com/privking/king-note-images/master/img/note/7ae1c256983120d31d9c374a78f32cf-1606143590-5143a3.png)

![66d87ad5938f48a14e2a5e26a9640ca](https://raw.githubusercontent.com/privking/king-note-images/master/img/note/66d87ad5938f48a14e2a5e26a9640ca-1606143619-bea424.png)



![ac8a0c38bdc9261adb0627ebc617917](https://raw.githubusercontent.com/privking/king-note-images/master/img/note/ac8a0c38bdc9261adb0627ebc617917-1606143648-e146c7.png)



```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

//32-3 = 29
private static final int COUNT_BITS = Integer.SIZE - 3;

//0000 0000 0000 0000 0000 0000 0000 0001
//0001 1111 1111 1111 1111 1111 1111 1111
//2 29次方-1  容量
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

//用高三位表示线程池状态
//地位表示worker数量
// runState is stored in the high-order bits
//1111 1111 1111 1111 1111 1111 1111 1111
//1110 0000 0000 0000 0000 0000 0000 0000
private static final int RUNNING    = -1 << COUNT_BITS;
//0000 0000 0000 0000 0000 0000 0000 0000
private static final int SHUTDOWN   =  0 << COUNT_BITS;
//0010 0000 0000 0000 0000 0000 0000 0000
private static final int STOP       =  1 << COUNT_BITS;
//0100 0000 0000 0000 0000 0000 0000 0000
private static final int TIDYING    =  2 << COUNT_BITS;、
//0110 0000 0000 0000 0000 0000 0000 0000
private static final int TERMINATED =  3 << COUNT_BITS;

// Packing and unpacking ctl
//获取最高三位
private static int runStateOf(int c)     { return c & ~CAPACITY; }
//获取去掉高3位的数，worker数量
private static int workerCountOf(int c)  { return c & CAPACITY; }
//
private static int ctlOf(int rs, int wc) { return rs | wc; }
```



